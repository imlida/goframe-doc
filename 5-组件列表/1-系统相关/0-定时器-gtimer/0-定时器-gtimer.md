---
title: '定时器-gtimer'
sidebar_position: 0
---

## 基本介绍

`gtimer` 是一个并发安全的高性能定时器，类似于 `Java` 的 `Timer`。 `gtimer` 底层采用了 **优先级队列**（ `PriorityQueue`）实现。

**使用场景**：

任何定时任务场景，大批量定时任务/延迟任务的场景，超时控制/频率控制的业务场景，对于定时时间准确度要求不高的业务场景。

**使用方式：**

```
import "github.com/gogf/gf/v2/os/gtimer"
```

**接口文档**：

[https://pkg.go.dev/github.com/gogf/gf/v2/os/gtimer](https://pkg.go.dev/github.com/gogf/gf/v2/os/gtimer)

**简要说明：**

01. `New` 方法用于创建自定义的任务定时器对象，并可在创建时`TimerOptions`传入参数，其中：
    - `Interval` 指定定时器的最小 `tick` 时间间隔。
    - `Quick` 指定定时器是否启动时就执行一次（默认为 `false`）。
02. `Add` 方法用于添加定时任务，其中：
    - `interval` 参数用于指定方法的执行的时间间隔。
    - `job` 参数为需要执行的任务方法。
03. `AddEntry` 方法添加定时任务，支持更多参数的控制。
04. `AddSingleton` 方法用于添加 **单例** 定时任务，即 **同时只能有一个该任务正在运行**。
05. `AddOnce` 方法用于添加只运行一次的定时任务，当运行一次数后该定时任务自动销毁。
06. `AddTimes` 方法用于添加运行指定次数的定时任务，当运行 `times` 次数后该定时任务自动销毁。
07. `Search` 方法用于根据名称进行定时任务搜索(返回定时任务 `*Entry` 对象指针)。
08. `Start` 方法用于启动定时器(使用 `New` 创建定时器时会自动启动)。
09. `Stop` 方法用于停止定时器。
10. `Close` 方法用于关闭定时器。

## 默认定时器

大部分的场景下使用默认的定时器即可。使用 `gtimer` 的默认定时器时，默认的定时检测间隔时间为 `100ms`，因此理论的时间间隔误差范围为 `0~100ms`。可以使用以下两种方式修改默认的定时器参数：

1. 使用启动参数
   - `gf.gtimer.interval=50`: 修改默认的时间刻度为 `50毫秒`
2. 使用环境变量
   - `GF_GTIMER_INTERVAL=50`

需要注意，定时器默认检测间隔时间越短，对 `CPU` 的使用量会越大。

## 注意事项🔥

1. 由于现代的计算机都是使用软件实现的定时器， **任何的定时器都是存在误差的**，不会完全精准，可能延迟，也甚至会提前，但是不会不执行。并且在定时间隔比较大，或者并发量大，负载较高的系统中尤其明显。参考链接： [https://github.com/golang/go/issues/14410](https://github.com/golang/go/issues/14410)
2. 由于误差是不可避免的，任何定时器的实现（不仅是框架的定时器，标准库的定时器亦是如此） **都不会使用系统时间**，而是使用一种固定的 `tick` 间隔。不要在定时器任务逻辑中使用系统时间来判断间隔做逻辑运算，这个时间的判断没有任何意义。
3. 在不考虑误差的前提下，定时间隔不会考虑任务的执行时间。例如，如果一项工作需要 `3` 分钟才能执行完成，并且计划每隔 `5` 分钟运行一次，那么每次任务之间只有 `2` 分钟的空闲时间。
4. 需要注意的是 **单例模式** 运行的定时任务，任务的执行时间会影响该任务下一次执行的 **开始时间**。例如：一个每间隔 `1` 秒执行的任务，运行耗时为 `1` 秒，那么在 **第1秒** 开始运行后，下一次任务将会在 **第3秒** 开始执行。因为中间有一次运行检查时发现有当前任务正在进行，因此退出等待下一次执行检查。

## 定时器与 `gcron` 区别

具体请查看章节 [定时任务-gcron与gtimer](/docs/组件列表/系统相关/定时任务-gcron/定时任务-gcron与gtimer)

## 相关文档

- [定时器-基本使用](/docs/组件列表/系统相关/定时器-gtimer/定时器-基本使用)
- [定时器-性能测试](/docs/组件列表/系统相关/定时器-gtimer/定时器-性能测试)